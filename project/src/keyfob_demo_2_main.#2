/*------------------------------------------------------------------------------
 *                          Silicon Laboratories, Inc.
 *                           http://www.silabs.com
 *                               Copyright 2010
 *------------------------------------------------------------------------------
 *
 *    FILE:       keyfob_demo_2_main.c
 *    TARGET:     Si4010 RevC
 *    TOOLCHAIN:  Keil
 *    DATE:       Nov 10, 2012,
 *    RELEASE:    1.0 (Tamas Nagy), ROM version 02.00
 *
 *------------------------------------------------------------------------------
 *
 *    DESCRIPTION:
 *      This file contains the main function for the Keil toolchain
 *      sample keyfob_demo_2 project.
 *
 *      BL51 linker directives for building this application:
 *
 *      BL51: PL(68) PW(78) IXREF RS(256)
 *            CODE (0x0-0x08FF)
 *            DATA (0x40)
 *            IDATA (0x70)
 *            XDATA (0x0900-0x107F)
 *            STACK (?STACK(0x90))
 *
 *------------------------------------------------------------------------------
 *
 *    INCLUDES:
 */

#include <intrins.h>  // must be included at top
#include "stdlib.h"
#include "si4010.h"
#include "si4010_api_rom.h"
#include "keyfob_demo_2.h"

sbit MY_LED = P0^4;  // LED

// --- SPI pins ---
sbit PIN_CS  = P1^1; // CS
sbit PIN_CLK = P0^6; // CLK
sbit PIN_D0  = P0^7; // MOSI
sbit PIN_D1  = P1^0; // MISO

float fReadFreq; 
float fReadDev;

// --- SPI helpers ---
void Delay_Safe(void) {
    unsigned char i;
    for(i=0;i<100;i++) _nop_(); // Keil intrinsic nop
}

unsigned char SPI_Swap(unsigned char b)
{
    unsigned char i, in = 0;
    for(i=0;i<8;i++)
    {
        if(b & 0x80) PIN_D0 = 1; else PIN_D0 = 0;
        Delay_Safe();
        PIN_CLK = 1; Delay_Safe();
        in <<= 1;
        if(PIN_D1) in |= 1;
        PIN_CLK = 0; Delay_Safe();
        b <<= 1;
    }
    return in;
}

// --- Main function ---
void main(void)
{
    PDMD = 1;
    PORT_CTRL &= ~(M_PORT_MATRIX | M_PORT_ROFF | M_PORT_STROBE);
    vSys_Setup(10); 
    vSys_BandGapLdo(1); 
    vSys_LedIntensity(3);

    lPartID = lSys_GetProdId();
    bIsr_DebounceCount = 0;

    // --- Button setup ---
    rBsrSetup.bButtonMask = bButtonMask_c;
    rBsrSetup.pbPtsReserveHead = abBsrPtsPlaceHolder;
    rBsrSetup.bPtsSize = 3;
    rBsrSetup.bPushQualThresh = 3;
    vBsr_Setup(&rBsrSetup);

    RTC_CTRL = (0x07 << B_RTC_DIV) | M_RTC_CLR | M_RTC_ENA;
    ERTC = 1; EA = 1;

    // --- PA & ODS setup for 315 MHz ---
    fDesiredFreqOOK = f_315_RkeFreqOOK_c;
    fDesiredFreqFSK = f_315_RkeFreqFSK_c;
    bFskDev = b_315_RkeFskDev_c;

    rPaSetup.bLevel = b_315_PaLevel_c;
    rPaSetup.wNominalCap = b_315_PaNominalCap_c;
    rPaSetup.bMaxDrv = b_315_PaMaxDrv_c;
    rPaSetup.fAlpha = 0.0;
    rPaSetup.fBeta = 0.0;
    vPa_Setup(&rPaSetup);

#ifdef OOK
    rOdsSetup.bModulationType = bModOOK_c;
    vStl_EncodeSetup(bEncodeManchester_c, NULL);
    fDesiredFreq = fDesiredFreqOOK;
    bPreamble = bPreambleManch_c;
#else
    rOdsSetup.bModulationType = bModFSK_c;
    vStl_EncodeSetup(bEnc_NoneNrz_c, NULL);
    fDesiredFreq = fDesiredFreqFSK;
    bPreamble = bPreambleNrz_c;
#endif

    rOdsSetup.bGroupWidth = 7;
    rOdsSetup.bClkDiv = 5;
    rOdsSetup.bEdgeRate = 0;
    rOdsSetup.bLcWarmInt = 0;
    rOdsSetup.bDivWarmInt = 5;
    rOdsSetup.bPaWarmInt = 4;
    rOdsSetup.wBitRate = 417;
    vOds_Setup(&rOdsSetup);

    vFCast_Setup();

    iBatteryMv = iMVdd_Measure(bBatteryWait_c);
    bBatStatus = (iBatteryMv >= iLowBatMv_c) ? 1 : 0;

    vDmdTs_RunForTemp(3);
    while(bDmdTs_GetSamplesTaken()==0);

    bStatus = 0; bRepeatCount = 0; bPrevBtn = 0;

    // --- Main loop ---
    while(1)
    {
        vButtonCheck();
        if(bButtonState)
        {
            // --- Read frequency from SPI ---
            if(!Load_Freq(0x001000))
            {
                MY_LED = 0; // Error blink or signal
                continue;
            }
            fDesiredFreq = fReadFreq;
            bFskDev = (unsigned char)fReadDev;

            bRepeatCount = bRepeatCount_c;
            vRepeatTxLoop();
        }
    }

// --- Load frequency from SPI flash ---
unsigned char Load_Freq(unsigned long addr)
{
    unsigned char h[2], d[8];
	unsigned char i;
    PIN_CS = 0; Delay_Safe(); Delay_Safe();

    SPI_Swap(0x03); // READ command
    SPI_Swap((addr>>16)&0xFF);
    SPI_Swap((addr>>8)&0xFF);
    SPI_Swap(addr&0xFF);
    
    h[0] = SPI_Swap(0xFF);
    h[1] = SPI_Swap(0xFF);
    
    // Check header
    if(h[0]!=0xA5 || h[1]!=0x5A) { PIN_CS = 1; return 0; }

    // Read 8 bytes frequency/dev
    for(i=0;i<8;i++) d[i] = SPI_Swap(0xFF);
    PIN_CS = 1;

    // Byte-to-float conversion
    {
        unsigned char j;
        unsigned char *pf = (unsigned char*)&fReadFreq;
        unsigned char *pd = (unsigned char*)&fReadDev;
        for(j=0;j<4;j++) { pf[j] = d[j]; pd[j] = d[j+4]; }
    }

    return 1;
}
}
