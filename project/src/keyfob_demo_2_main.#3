/*------------------------------------------------------------------------------
 * Silicon Laboratories, Inc.
 * Si4010 RevC
 * Toolchain: Keil C51
 * Bit-banged SPI Flash Read (CMD 0x03)
 *------------------------------------------------------------------------------*/
/////////////GSM//////////
//SPI_byte = (WinHex_byte << 1) | 0x01
//////////////////////////////////////
#include <intrins.h>
#include "stdlib.h"
#include "si4010.h"
#include "si4010_api_rom.h"
#include "keyfob_demo_2.h"
#define BIN_CHUNK 64
BYTE binChunk[BIN_CHUNK] _xdata;  // Use external data for large arrays

/*------------------------------------------------------------------------------
 * TYPE DEFINITIONS (Keil-safe)
 *------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
 * GPIO DEFINITIONS
 *------------------------------------------------------------------------------*/
sbit MY_LED    = P0^4;

/* SPI FLASH (bit-banged) */
sbit SPI_CS    = P1^1;   /* GPIO9  */
sbit SPI_CLK   = P0^6;   /* GPIO6  */
sbit SPI_MOSI  = P1^0;   /* GPIO8  */
sbit SPI_MISO  = P0^7;   /* GPIO7  */

void spi_flash_read(LWORD addr, BYTE *buf, BYTE len);
void vStl_ByteTx(BYTE *buf, BYTE len);

/*------------------------------------------------------------------------------
 * SPI LOW-LEVEL SUPPORT
 *------------------------------------------------------------------------------*/
/* Function to output BIN data to a file or buffer (for simplicity, we use a UART here) */
void output_bin_data(void)
{
    LWORD addr = 0;  // Start from the beginning of the flash memory
    BYTE remaining = 4096; // Assuming the BIN data size is 4096 bytes
    BYTE sendSize;  // Number of bytes to send in each chunk
    BYTE i = 0;

    while (remaining)
    {
        sendSize = (remaining > BIN_CHUNK) ? BIN_CHUNK : remaining; // Send in chunks
        spi_flash_read(addr, binChunk, sendSize);  // Read chunk from SPI flash
        
        // Output the chunk of data (via UART, or any other method)
        for (i = 0; i < sendSize; i++)
        {
            // UART_SendData(binChunk[i]); // Uncomment and define UART send method
        }

        addr += sendSize;  // Move address forward
        remaining -= sendSize;  // Update remaining bytes
    }
}

/* SPI delay function */
void spi_delay(void)
{
    BYTE i;
    for (i = 0; i < 30; i++)
        _nop_();
}

/* SPI Initialization */
void spi_init(void)
{
    SPI_CS = 1;   // idle HIGH
    SPI_CLK = 0;   // idle LOW (SPI mode 0)
    SPI_MOSI = 0;

    spi_delay();
}

/* SPI WRITE BYTE (MSB first) */
void spi_write_byte(BYTE _data)
{
    BYTE i;

    for (i = 0; i < 8; i++)
    {
        SPI_CLK = 0;

        SPI_MOSI = (_data & 0x80) ? 1 : 0;
        _data <<= 1;

        spi_delay();
        SPI_CLK = 1;     // rising edge clocks data
        spi_delay();
    }

    SPI_CLK = 0;
}

/* SPI FLASH READ (CMD = 0x03) */
void spi_flash_read(LWORD addr, BYTE *buf, BYTE len)
{
    BYTE i;

    SPI_CS = 1;
    spi_delay();

    SPI_CS = 0;                 // assert CS
    spi_delay();

    spi_write_byte(0x03);       // READ
    spi_write_byte(addr >> 16);
    spi_write_byte(addr >> 8);
    spi_write_byte(addr);

    for (i = 0; i < len; i++)
        buf[i] = spi_read_byte();

    spi_delay();
    SPI_CS = 1;                 // deassert CS
}

/* Function to read frequency from flash @ 0x000000 */
float spi_flash_read_freq(void)
{
    BYTE  b[4];
    spi_flash_read(0x000000UL, b, 4);

    if(b[0] == 0x00 || b[0] == 0xFF) return 0.0;
    if(b[0] == 0x29 && b[1] == 0xA0) return 433979050.0;
    if(b[0] == 0xE9 && b[1] == 0xF5) return 316703093.0;
    return 0;
}

/* Read SPI Flash ID */
void spi_flash_read_id(BYTE *id)
{
    SPI_CS = 1;
    spi_delay();
    SPI_CS = 0;
    spi_delay();

    spi_write_byte(0x9F);   // JEDEC ID
    id[0] = spi_read_byte();
    id[1] = spi_read_byte();
    id[2] = spi_read_byte();

    SPI_CS = 1;
}

/* Main loop */
void main(void)
{
    PDMD = 1;
    PORT_CTRL &= ~(M_PORT_MATRIX | M_PORT_ROFF | M_PORT_STROBE);
    PORT_CTRL |= M_PORT_STROBE;
    PORT_CTRL &= (~M_PORT_STROBE);
    GPIO_LED = 0;

    vSys_Setup(10);
    vSys_SetMasterTime(0);
    vSys_BandGapLdo(1);

    vSys_LedIntensity(3);
    lLEDOnTime = 20;
    lPartID = lSys_GetProdId();
    bIsr_DebounceCount = 0;
    
    while (1)
    {
        vButtonCheck();  // Check if the button is pressed
        MY_LED = 1;

        if (bButtonState)  // Button pressed
        {
            MY_LED = 0;  // Turn off LED when button is pressed
            output_bin_data();
            bButtonState = 0;  // Clear the button press state after action
        }
        else if ((lSys_GetMasterTime() >> 5) > bMaxWaitForPush_c)
        {
            if ((PROT0_CTRL & M_NVM_BLOWN) > 1) // Check for burn state
            {
                EA = 0;  // Disable interrupts
                vSys_Shutdown();
            }
        }
    }
}

/* Function to transmit a byte */
void vStl_ByteTx(BYTE *buf, BYTE len)
{
    BYTE i;

    for (i = 0; i < len; i++) {
        spi_write_byte(buf[i]);
    }
}

/* Repeat TX Loop */
void vRepeatTxLoop(void)
{
    LWORD addr;
    WORD remaining;
    BYTE sendSize;

    float fFlashFreqHz = spi_flash_read_freq();

    if (fFlashFreqHz != 0.0) {
        vFCast_Tune(fFlashFreqHz); // Tune using frequency from flash
    }
    else {
        vFCast_Tune(315000000.0); // Default frequency
    }

    if (rOdsSetup.bModulationType == bModFSK_c)
        vFCast_FskAdj(bFskDev);

    while (0 == bDmdTs_GetSamplesTaken());
    vPa_Tune(iDmdTs_GetLatestTemp());

    vStl_PreLoop();

    do
    {
        addr = 0;
        remaining = 4096;

        vStl_StartTx();

        while (remaining)
        {
            sendSize = (remaining > BIN_CHUNK) ? BIN_CHUNK : remaining;

            spi_flash_read(addr, binChunk, sendSize);
            vStl_ByteTx(binChunk, sendSize);

            addr += sendSize;
            remaining -= sendSize;
        }

        vStl_StopTx();

        lTimestamp = lSys_GetMasterTime();
        while ((lSys_GetMasterTime() - lTimestamp) < wRepeatInterval_c);

    } while(--bRepeatCount);

    vStl_PostLoop();
    vSys_SetMasterTime(0);
}

/* Interrupt Service Routine */
void isr_rtc(void) interrupt INTERRUPT_RTC using 1
{
    RTC_CTRL &= ~M_RTC_INT;
    vSys_IncMasterTime(5);
    bIsr_DebounceCount++;
    if ((bIsr_DebounceCount % bDebounceInterval_c) == 0)
    {
        vBsr_Service();
    }
}

/* Button Check */
void vButtonCheck(void)
{
    ERTC = 0;
    bButtonState = 0;

    if (bBsr_GetPtsItemCnt())
    {
        bButtonState = wBsr_Pop() & 0xFF;

        if (bPrevBtn)
        {
            bPrevBtn = bButtonState;
            bButtonState = 0;
        }
        else
        {
            bPrevBtn = bButtonState;
        }
    }

    ERTC = 1;
}

void vPacketAssemble(void)
{ 
    BYTE i;

    pbFrameHead = abFrame;
    bFrameSize = bFrameSize_c;

    for (i = 0; i < bPreambleSize_c; i++)
    {
        abFrame[i] = bPreamble;
    }

    bStatus &= ~M_ButtonBits_c;
    bStatus |= bButtonState & M_ButtonBits_c;

    abFrame[bFrameSize_c - 11] = bSync1_c;
    abFrame[bFrameSize_c - 10] = bSync2_c;
    abFrame[bFrameSize_c - 9] = ((BYTE *)&lPartID)[0];
    abFrame[bFrameSize_c - 8] = ((BYTE *)&lPartID)[1];
    abFrame[bFrameSize_c - 7] = ((BYTE *)&lPartID)[2];
    abFrame[bFrameSize_c - 6] = ((BYTE *)&lPartID)[3];
    abFrame[bFrameSize_c - 5] = bStatus;
    abFrame[bFrameSize_c - 4] = ((BYTE *)&iBatteryMv)[0];
    abFrame[bFrameSize_c - 3] = ((BYTE *)&iBatteryMv)[1];
    abFrame[bFrameSize_c - 2] = 0;    // CRC
    abFrame[bFrameSize_c - 1] = 0;    // CRC

    vCalculateCrc();
}

void vCalculateCrc(void)
{
    BYTE i, j;
    WORD wCrc;
    wCrc = 0xffff;

    for (j = bPayloadStartIndex_c; j < bPayloadStartIndex_c + bPayloadSize_c; j++)
    {
        wCrc = wCrc ^ ((WORD)abFrame[j] << 8);

        for (i = 8; i != 0; i--)
        {
            if (wCrc & 0x8000)
            {
                wCrc = (wCrc << 1) ^ 0x8005;
            }
            else
            {
                wCrc <<= 1;
            }
        }
    }

    abFrame[bFrameSize_c - 2] = ((BYTE*)&wCrc)[0];
    abFrame[bFrameSize_c - 1] = ((BYTE*)&wCrc)[1];
}

/* MSB to LSB conversion for FSK modulation */
void vConvertPacket(BYTE bModType)
{
    BYTE i, low, high;

    if (bModType)
    {
        bModType = 0xff;
    }

    for (i = 0; i < sizeof(abFrame); i++)
    {
        low = abConvTable[(abFrame[i] & 0xf0) >> 4] & 0x0f;
        high = abConvTable[abFrame[i] & 0x0f] & 0xf0;
        abFrame[i] = (high | low) ^ bModType;
    }
}
